shift-roster-agent/
    --- CODE END ---
  streamlit_app.py
    --- CODE START ---
    import streamlit as st
    
    from app.graph import build_graph
    from app.state import ShiftState
    from app.helper import is_assistant_echo
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Page config
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    st.set_page_config(
        page_title="Shift Roster Assistant",
        page_icon="ğŸ“…",
        layout="wide",
    )
    
    st.title("ğŸ“… Shift Roster Assistant")
    st.caption("Generate and manage 24Ã—7, 24Ã—5, and 16Ã—5 shift schedules")
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Initialize session state
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if "graph" not in st.session_state:
        st.session_state.graph = build_graph()
    
    if "state" not in st.session_state:
        st.session_state.state = ShiftState()
    
    if "chat" not in st.session_state:
        st.session_state.chat = []  # [{"role": "...", "content": "..."}]
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Sidebar (optional controls)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    with st.sidebar:
        st.header("âš™ï¸ Controls")
    
        if st.button("ğŸ”„ Reset conversation"):
            st.session_state.state = ShiftState()
            st.session_state.chat = []
            st.success("Conversation reset")
    
        st.markdown("---")
        st.markdown("**Examples:**")
        st.markdown(
            """
            â€¢ Generate 24x7 for 2 weeks  
            â€¢ Generate 24x5  
            â€¢ Add holiday on 15 Jan  
            â€¢ P2 on leave Wednesday  
            """
        )
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Display chat history
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    for msg in st.session_state.chat:
        with st.chat_message(msg["role"]):
            st.markdown(msg["content"])
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # User input
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    user_input = st.chat_input("Enter your scheduling request...")
    
    if user_input:
        user_input = user_input.strip()
    
        # Ignore assistant echoes like "yes", "ok"
        if is_assistant_echo(user_input):
            with st.chat_message("assistant"):
                st.markdown("ğŸ™‚ You can tell me what you want to do.")
        else:
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # Show user message
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            st.session_state.chat.append(
                {"role": "user", "content": user_input}
            )
            with st.chat_message("user"):
                st.markdown(user_input)
    
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # Update state
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            state = st.session_state.state
            state.user_input = user_input
            state.final_output = None
    
            state.conversation_history.append({
                "role": "user",
                "content": user_input
            })
    
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # Invoke LangGraph
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            result = st.session_state.graph.invoke(state)
            assistant_reply = result["final_output"]
    
            # Save assistant response
            state.conversation_history.append({
                "role": "assistant",
                "content": assistant_reply
            })
    
            st.session_state.chat.append(
                {"role": "assistant", "content": assistant_reply}
            )
    
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # Show assistant message
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            with st.chat_message("assistant"):
                st.markdown(assistant_reply)
    --- CODE END ---
  app/
    graph.py
      --- CODE START ---
      from langgraph.graph import StateGraph
      from app.state import ShiftState
      
      # Nodes
      from app.nodes.llm_intent import llm_intent_node
      from app.nodes.parser import parse_input
      from app.nodes.router import route_pattern
      from app.nodes.validator import validate_schedule
      from app.nodes.renderer import render_output
      from app.nodes.conversation_controller import conversation_controller
      # Patterns
      from app.patterns.pattern_a_24x7 import build_pattern_a
      from app.patterns.pattern_b_24x5 import build_pattern_b
      from app.patterns.pattern_c_16x5 import build_pattern_c
      
      # Modules
      from app.modules.rotation_24x7 import rotate_24x7
      from app.modules.holidays import apply_holidays
      from app.modules.leave_adjustment import apply_leaves
      
      
      def build_graph():
          graph = StateGraph(ShiftState)
      
          # Nodes
          graph.add_node("conversation", conversation_controller)
          graph.add_node("parse", parse_input)
      
          graph.add_node("pattern_a", build_pattern_a)
          graph.add_node("pattern_b", build_pattern_b)
          graph.add_node("pattern_c", build_pattern_c)
      
          graph.add_node("rotate_24x7", rotate_24x7)
          graph.add_node("holiday", apply_holidays)
          graph.add_node("leave", apply_leaves)
          graph.add_node("validate", validate_schedule)
          graph.add_node("render", render_output)
      
          # Entry
          graph.set_entry_point("conversation")
      
          # ğŸ”€ Conversation decides next step
          graph.add_conditional_edges(
              "conversation",
              lambda state: state.next_node,
              {
                  "parse": "parse",
                  "leave": "leave",
                  "render": "render",
              },
          )
      
          # Pattern routing
          graph.add_conditional_edges(
              "parse",
              route_pattern,
              {
                  "pattern_a": "pattern_a",
                  "pattern_b": "pattern_b",
                  "pattern_c": "pattern_c",
              },
          )
      
          # Flow
          graph.add_edge("pattern_a", "rotate_24x7")
          graph.add_edge("rotate_24x7", "holiday")
      
          graph.add_edge("pattern_b", "holiday")
          graph.add_edge("pattern_c", "holiday")
      
          graph.add_edge("holiday", "leave")
          graph.add_edge("leave", "validate")
          graph.add_edge("validate", "render")
      
          graph.set_finish_point("render")
      
          return graph.compile()
      --- CODE END ---
    helper.py
      --- CODE START ---
      def is_assistant_echo(text: str) -> bool:
          return text.strip().lower() in {"yes", "yeah", "yep", "ok", "okay"}
      --- CODE END ---
    main.py
      --- CODE START ---
      from app.graph import build_graph
      from app.state import ShiftState
      from app.helper import is_assistant_echo
      
      
      def main():
          graph = build_graph()
          state = ShiftState()
      
          print("Shift Roster Assistant (type 'exit' to quit)\n")
      
          while True:
              user_query = input("Enter your scheduling request: ").strip()
      
              if user_query.lower() in {"exit", "quit"}:
                  print("Goodbye ğŸ‘‹")
                  break
      
              # Save user input
              state.user_input = user_query
              state.final_output = None
      
              # Ignore assistant echoes
              if is_assistant_echo(user_query):
                  print("ğŸ™‚ You can tell me what you want to do.")
                  continue
      
              # ğŸ”¥ ADD USER MESSAGE TO HISTORY
              state.conversation_history.append({
                  "role": "user",
                  "content": user_query
              })
      
              result = graph.invoke(state)
              assistant_reply = result["final_output"]
      
              # ğŸ”¥ ADD ASSISTANT MESSAGE TO HISTORY
              state.conversation_history.append({
                  "role": "assistant",
                  "content": assistant_reply
              })
      
              print(assistant_reply)
              print()
      
      
      if __name__ == "__main__":
          main()
      --- CODE END ---
    state.py
      --- CODE START ---
      from dataclasses import dataclass, field
      from typing import Dict, List, Optional
      from datetime import datetime, timedelta
      
      
      @dataclass
      class ShiftState:
          conversation_history: List[Dict[str, str]] = field(default_factory=list)
      
          user_input: Optional[str] = None
          pattern: Optional[str] = None
          weeks: int = 0
          weeks_confirmed: bool = False
      
          holidays: List[str] = field(default_factory=list)
          leaves: Dict = field(default_factory=dict)
      
          people: List[str] = field(
              default_factory=lambda: ["P1", "P2", "P3", "P4", "P5", "P6"]
          )
      
          final_schedule: List[Dict] = field(default_factory=list)
          adjustment_log: List[str] = field(default_factory=list)
      
          final_output: Optional[str] = None
      
          # ğŸ§  Conversational routing
          next_node: Optional[str] = None
      
          start_date: datetime = field(
              default_factory=lambda: (
                  datetime.now() - timedelta(days=datetime.now().weekday())
              )
          )
          day_delta: timedelta = field(default_factory=lambda: timedelta(days=1))
      --- CODE END ---
    config/
      people.py
        --- CODE START ---
        PEOPLE_MAP = {
                    "P1": "Mayur Bodkhe",
                    "P2": "Mithub Kumar Kandagatla",
                    "P3": "Kishan Singh Bagga",
                    "P4": "Kunta Bhargav Sai",
                    "P5": "Gaurav Tikar",
                    "P6": "Buffer"
                }
        --- CODE END ---
    llm/
      azure_client.py
        --- CODE START ---
        from openai import AzureOpenAI
        import os
        os.environ["AZURE_OPENAI_API_KEY"] = "f27856eb72df4e37b8926a39ad2e5af6"
        os.environ["AZURE_OPENAI_ENDPOINT"] = 'https://e360-ai.openai.azure.com/'
        # os.environ['OPENAI_API_VERSION'] = get_vault_secret('chatbot-api-version')#"2023-05-15"
        
        client = AzureOpenAI(
            api_key=os.getenv("AZURE_OPENAI_API_KEY"),
            api_version="2024-02-15-preview",
            azure_endpoint=os.getenv("AZURE_OPENAI_ENDPOINT"),
        )
        
        DEPLOYMENT_NAME = "gpt-4o"
        
        --- CODE END ---
      fallback_parser.py
        --- CODE START ---
        import re
        
        
        def fallback_parse_intent(user_query: str) -> dict:
            text = user_query.lower()
            if text.isdigit():
                return {
                    "service_type": None,
                    "weeks": int(text),
                    "leaves": {},
                    "holidays": [],
                }
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # Service type
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if "24x7" in text or "24Ã—7" in text:
                service_type = "24x7"
            elif "24x5" in text or "24Ã—5" in text:
                service_type = "24x5"
            elif "16x5" in text or "16Ã—5" in text:
                service_type = "16x5"
            else:
                raise ValueError("Unable to detect service type")
        
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # Weeks
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            match = re.search(r"(\d+)\s*week", text)
            weeks = int(match.group(1)) if match else 1
        
            return {
                "service_type": service_type,
                "weeks": weeks,
                "leaves": {},
                "holidays": [],
            }
        --- CODE END ---
      intent_parser.py
        --- CODE START ---
        import json
        from app.llm.azure_client import client, DEPLOYMENT_NAME
        from app.llm.intent_prompt import SYSTEM_PROMPT
        from app.llm.fallback_parser import fallback_parse_intent
        
        
        def parse_intent(user_query: str, history: list) -> dict:
            messages = [{"role": "system", "content": SYSTEM_PROMPT}]
            messages.extend(history)
            messages.append({"role": "user", "content": user_query})
        
            response = client.chat.completions.create(
                model=DEPLOYMENT_NAME,
                messages=messages,
                temperature=0
            )
        
            content = response.choices[0].message.content.strip()
            return json.loads(content)
        --- CODE END ---
      intent_prompt.py
        --- CODE START ---
        SYSTEM_PROMPT = """
                You are an intent classifier for a shift roster assistant.
        
                Classify the user's intent and extract data.
        
                Return ONLY valid JSON in this format:
        
                {
                  "intent_type": "create_schedule | clarify_weeks | add_leave | add_holiday | update_weeks | explain | reset | unknown",
                  "service_type": "24x7 | 24x5 | 16x5 | null",
                  "weeks": number | null,
                  "leaves": { "P2": "Wed" },
                  "holidays": ["15 Jan"]
                }
        
                Rules:
                - Use create_schedule only when user wants a new roster
                - Use clarify_weeks when user only gives a number
                - Use add_leave / add_holiday only if modifying existing schedule
                - If unsure, intent_type = unknown
                - No explanations, no extra text
                """
        --- CODE END ---
      output_formatter.py
        --- CODE START ---
        from app.llm.azure_client import client, DEPLOYMENT_NAME
        from app.config.people import PEOPLE_MAP
        
        FORMAT_PROMPT = """
                You are a formatter.
        
                Rules:
                - Do NOT change assignments
                - Do NOT invent people
                - Replace P-codes using the mapping
                - Improve readability
                - Keep dates, shifts, and structure intact
                """
        
        
        def format_schedule(raw_output: str) -> str:
            mapping_text = "\n".join(
                f"{k} = {v}" for k, v in PEOPLE_MAP.items()
            )
        
            response = client.chat.completions.create(
                model=DEPLOYMENT_NAME,
                messages=[
                    {"role": "system", "content": FORMAT_PROMPT},
                    {"role": "user", "content": f"""
                Mapping:
                {mapping_text}
        
                Schedule:
                {raw_output}
                """}
                ],
                temperature=0,
            )
        
            return response.choices[0].message.content.strip()
        --- CODE END ---
    modules/
      holidays.py
        --- CODE START ---
        def apply_holidays(state):
            for holiday in state.holidays:
                state.adjustment_log.append(
                    f"{holiday}: Holiday checks only at 11:00, 16:00, 22:00 IST"
                )
            return state
        --- CODE END ---
      leave_adjustment.py
        --- CODE START ---
        BUFFER_PRIORITY = ["P4", "P3", "P5", "P2"]
        
        def apply_leaves(state):
            """
            Apply planned leaves using buffer priority.
            - Replaces the absent person with a buffer
            - Logs adjustments
            - Returns state (CRITICAL for LangGraph)
            """
        
            if not state.leaves or not state.final_schedule:
                return state
        
            for person, day in state.leaves.items():
                for week in state.final_schedule:
        
                    # Defensive checks
                    if not isinstance(week, dict):
                        continue
                    if day not in week:
                        continue
        
                    shifts = week[day]
        
                    for shift, assigned in shifts.items():
                        if assigned != person:
                            continue
        
                        # Find first available buffer
                        for buffer in BUFFER_PRIORITY:
                            shifts[shift] = buffer
                            state.adjustment_log.append(
                                f"{person} OFF on {day}, covered by {buffer}"
                            )
                            break
        
            return state
        --- CODE END ---
      rotation.py
        --- CODE START ---
        FOLLOW_CHAIN = {
            "P2": "P1",
            "P3": "P2",
            "P4": "P3",
            "P5": "P4",
            "P1": "P5",
        }
        
        DAY_ORDER = ["Mon","Tue","Wed","Thu","Fri","Sat","Sun"]
        
        def rotate_24x7(state):
            if state.weeks == 1:
                return state
        
            weekly_schedules = []
            current_week = state.final_schedule
        
            weekly_schedules.append(current_week)
        
            p1_night_weeks = 0
        
            for week in range(2, state.weeks + 1):
                next_week = {}
        
                for day in DAY_ORDER:
                    next_week[day] = {}
        
                    for shift, person in current_week[day].items():
                        # Enforce P1 7N + 4OFF
                        if person == "P1" and shift == "ğŸŸ¦":
                            if p1_night_weeks >= 1:
                                continue
                            p1_night_weeks += 1
        
                        next_week[day][shift] = FOLLOW_CHAIN.get(person, person)
        
                weekly_schedules.append(next_week)
                current_week = next_week
        
            state.final_schedule = weekly_schedules
            return state
        --- CODE END ---
      rotation_24x7.py
        --- CODE START ---
        FOLLOW_CHAIN = {
            "P1": "P5",
            "P2": "P1",
            "P3": "P2",
            "P4": "P3",
            "P5": "P4",
        }
        
        DAY_ORDER = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
        
        REAL_PEOPLE = ["P1", "P2", "P3", "P4", "P5"]
        BUFFER = "P6"
        
        MAX_CONSECUTIVE_NIGHTS = 5
        
        
        def ordered_candidates(start_person):
            """
            Follow-chain order, then remaining real people
            """
            order = []
            current = start_person
        
            while current and current not in order:
                order.append(current)
                current = FOLLOW_CHAIN.get(current)
        
            for p in REAL_PEOPLE:
                if p not in order:
                    order.append(p)
        
            return order
        
        
        def rotate_24x7(state):
            """
            24Ã—7 rotation engine with:
            - Follow-chain rotation for all shifts
            - Week-1 Night relaxation
            - Date-based Night rest
            - HARD RULE: Night â†’ no Morning next day
            - HARD RULE: iterate all real candidates before Buffer
            - HARD RULE: max 5 consecutive Nights (APPLIES TO WEEK-1 TOO)
            """
        
            if not state.final_schedule or state.weeks <= 1:
                return state
        
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # Initialize night streaks FROM WEEK-1
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            night_streak = {p: 0 for p in REAL_PEOPLE}
        
            week1 = state.final_schedule[0]
            for day in DAY_ORDER:
                night_worker = week1[day]["ğŸŸ¦"]
                for p in night_streak:
                    if p == night_worker:
                        night_streak[p] += 1
                    else:
                        night_streak[p] = 0
        
            last_night_worker = week1["Sun"]["ğŸŸ¦"]
        
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # Build remaining weeks
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            while len(state.final_schedule) < state.weeks:
                prev_week = state.final_schedule[-1]
                next_week = {}
        
                for day in DAY_ORDER:
                    next_week[day] = {}
        
                    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    # MORNING (ğŸŸ¨)
                    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    prev_morning = prev_week[day]["ğŸŸ¨"]
                    morning_assigned = False
        
                    for candidate in ordered_candidates(FOLLOW_CHAIN.get(prev_morning)):
                        # HARD RULE: Night â†’ no Morning next day
                        if candidate == last_night_worker:
                            continue
                        next_week[day]["ğŸŸ¨"] = candidate
                        morning_assigned = True
                        break
        
                    if not morning_assigned:
                        next_week[day]["ğŸŸ¨"] = BUFFER
        
                    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    # AFTERNOON (ğŸŸ§)
                    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    prev_afternoon = prev_week[day]["ğŸŸ§"]
                    afternoon_assigned = False
        
                    for candidate in ordered_candidates(FOLLOW_CHAIN.get(prev_afternoon)):
                        if candidate == next_week[day]["ğŸŸ¨"]:
                            continue
                        next_week[day]["ğŸŸ§"] = candidate
                        afternoon_assigned = True
                        break
        
                    if not afternoon_assigned:
                        next_week[day]["ğŸŸ§"] = BUFFER
        
                    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    # NIGHT (ğŸŸ¦)
                    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    prev_night = prev_week[day]["ğŸŸ¦"]
                    night_assigned = False
        
                    for candidate in ordered_candidates(FOLLOW_CHAIN.get(prev_night)):
                        if candidate in next_week[day].values():
                            continue
                        if night_streak.get(candidate, 0) >= MAX_CONSECUTIVE_NIGHTS:
                            continue
        
                        next_week[day]["ğŸŸ¦"] = candidate
                        night_assigned = True
                        break
        
                    if not night_assigned:
                        next_week[day]["ğŸŸ¦"] = BUFFER
        
                    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    # Update night streaks (date-based)
                    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    today_night = next_week[day]["ğŸŸ¦"]
        
                    for p in night_streak:
                        if p == today_night:
                            night_streak[p] += 1
                        else:
                            night_streak[p] = 0
        
                    last_night_worker = today_night
        
                state.final_schedule.append(next_week)
        
            return state
        --- CODE END ---
    nodes/
      conversation_controller.py
        --- CODE START ---
        import json
        from app.llm.azure_client import client, DEPLOYMENT_NAME
        
        
        SYSTEM_PROMPT = """
        You are a conversational shift roster assistant.
        
        You must decide the NEXT action.
        
        CRITICAL RULES:
        - If the user clearly asks to GENERATE or CREATE a schedule,
          it means a NEW schedule, even if one already exists.
        - In that case, reset the old schedule.
        - NEVER ask to reconfirm information already provided in the same sentence.
        - Ask only ONE question at a time.
        - If pattern AND weeks are known â†’ build schedule.
        
        Possible actions:
        - ask_clarification
        - build_schedule
        - update_schedule
        - explain
        - idle
        
        Return ONLY valid JSON:
        
        {
          "action": "ask_clarification | build_schedule | update_schedule | explain | idle",
          "message": "string or null",
          "data": {
            "pattern": "24x7 | 24x5 | 16x5 | null",
            "weeks": number or null,
            "leaves": {},
            "holidays": []
          }
        }
        """
        
        
        def conversation_controller(state):
            messages = [{"role": "system", "content": SYSTEM_PROMPT}]
            messages.extend(state.conversation_history)
        
            messages.append({
                "role": "user",
                "content": f"""
        User input: {state.user_input}
        
        Confirmed:
        - pattern: {state.pattern}
        - weeks: {state.weeks}
        - weeks_confirmed: {state.weeks_confirmed}
        - schedule_exists: {bool(state.final_schedule)}
        """
            })
        
            response = client.chat.completions.create(
                model=DEPLOYMENT_NAME,
                messages=messages,
                temperature=0,
            )
        
            decision = json.loads(response.choices[0].message.content)
        
            action = decision["action"]
            data = decision.get("data", {})
            message = decision.get("message")
        
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # ğŸ”¥ HARD RESET for NEW schedule
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if action == "build_schedule" and state.final_schedule:
                state.final_schedule.clear()
                state.adjustment_log.clear()
                state.holidays.clear()
                state.leaves.clear()
                state.pattern = None
                state.weeks = 0
                state.weeks_confirmed = False
        
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # Update state from LLM
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if data.get("pattern"):
                state.pattern = data["pattern"]
        
            if data.get("weeks") is not None:
                state.weeks = data["weeks"]
                state.weeks_confirmed = True
        
            if data.get("leaves"):
                state.leaves.update(data["leaves"])
        
            if data.get("holidays"):
                state.holidays.extend(data["holidays"])
        
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # Decide next node
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if action == "ask_clarification":
                state.final_output = message
                state.next_node = "render"
        
            elif action == "build_schedule":
                state.next_node = "parse"
        
            elif action == "update_schedule":
                state.next_node = "leave"
        
            else:
                state.next_node = "render"
        
            return state
        --- CODE END ---
      dispatch.py
        --- CODE START ---
        def dispatch(state):
            """
            Decide whether we are building a new schedule
            or editing an existing one.
            """
        
            if state.intent_type == "create_schedule":
                return {"mode": "build"}
        
            if state.intent_type in {"add_holiday", "add_leave", "update_weeks"}:
                if not state.final_schedule:
                    state.final_output = (
                        "I couldn't find an existing schedule. "
                        "Please generate a schedule first."
                    )
                    return {"mode": "stop"}
                return {"mode": "edit"}
        
            # fallback
            state.final_output = (
                "I didnâ€™t understand that. "
                "Try: generate 24x7 for 2 weeks."
            )
            return {"mode": "stop"}
        --- CODE END ---
      input_gate.py
        --- CODE START ---
        def ask_initial_question(state):
            # If input is missing, stop execution by raising
            if not state.user_input:
                raise ValueError(
                    "Do you want 24Ã—7, 24Ã—5, or 16Ã—5, and for how many weeks?"
                )
            return {}
        --- CODE END ---
      intent_router.py
        --- CODE START ---
        def route_by_intent(state):
            intent = state.intent.intent_type
        
            if intent == "greeting":
                state.final_output = "Do you want 24Ã—7, 24Ã—5, or 16Ã—5, and for how many weeks?"
                return "render"
        
            if intent == "create_schedule":
                return "parse"
        
            if intent == "add_leave":
                return "apply_leave"
        
            return "render"
        --- CODE END ---
      llm_intent.py
        --- CODE START ---
        def llm_intent_node(state):
            # Conversation is now handled by conversation_controller
            return state
        --- CODE END ---
      output_llm.py
        --- CODE START ---
        def format_output_llm(state):
            prompt = f"""
        Format this schedule nicely.
        Replace IDs with names.
        Do not change assignments.
        
        Schedule:
        {state.final_output}
        """
            response = llm.invoke(prompt)
            state.final_output = response.content
            return state
        --- CODE END ---
      parser.py
        --- CODE START ---
        def parse_input(state):
            """
            LLM already decided we have enough info.
            This node just passes control forward.
            """
            return state
        --- CODE END ---
      renderer.py
        --- CODE START ---
        from app.llm.output_formatter import format_schedule
        
        
        def render_output(state):
            """
            Renders either:
            - clarification / conversational response
            - or full shift roster
            """
        
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # Case 1: Explicit response already set
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if state.final_output:
                return {
                    "final_output": state.final_output
                }
        
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # Case 2: No schedule yet â†’ conversational fallback
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if not state.final_schedule:
                return {
                    "final_output": (
                        "Hi ğŸ‘‹ I can help you generate and manage shift rosters.\n\n"
                        "You can say things like:\n"
                        "â€¢ Generate 24x7 for 2 weeks\n"
                        "â€¢ Generate 24x5\n"
                        "â€¢ Add holiday on 15 Jan\n"
                        "â€¢ P2 on leave Wednesday"
                    )
                }
        
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # Case 3: Markdown table schedule rendering
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            output_lines = []
            start_date = state.start_date
        
            for week_index, week in enumerate(state.final_schedule, start=1):
                output_lines.append(f"\n### ğŸ“… Week {week_index}\n")
                output_lines.append("| Day | Date | Morning (ğŸŸ¨) | Afternoon (ğŸŸ§) | Night (ğŸŸ¦) |")
                output_lines.append("|-----|------|--------------|----------------|-----------|")
        
                for day, shifts in week.items():
                    date_str = start_date.strftime("%d %b %Y")
                    start_date += state.day_delta
        
                    def fmt(val):
                        if isinstance(val, list):
                            return ", ".join(val)
                        return val if val else "-"
        
                    morning = fmt(shifts.get("ğŸŸ¨"))
                    afternoon = fmt(shifts.get("ğŸŸ§"))
                    night = fmt(shifts.get("ğŸŸ¦")) if state.pattern != "16x5" else "-"
        
                    output_lines.append(
                        f"| {day} | {date_str} | {morning} | {afternoon} | {night} |"
                    )
        
            # Adjustment log
            if state.adjustment_log:
                output_lines.append("\n### ğŸ”§ Adjustment Log\n")
                for log in state.adjustment_log:
                    output_lines.append(f"- {log}")
        
            final_text = "\n".join(output_lines)
            final_text = format_schedule(final_text)
        
            final_text += "\n\nWould you like to add leaves, holidays, or make changes?"
        
            return {"final_output": final_text}
        --- CODE END ---
      router.py
        --- CODE START ---
        def route_pattern(state):
            if state.pattern == "24x7":
                return "pattern_a"
            if state.pattern == "24x5":
                return "pattern_b"
            return "pattern_c"
        --- CODE END ---
      validator.py
        --- CODE START ---
        DAY_ORDER = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
        
        
        def validate_schedule(state):
            if not isinstance(state.final_schedule, list):
                raise TypeError(
                    f"final_schedule must be list, got {type(state.final_schedule)}"
                )
        
            for w, week in enumerate(state.final_schedule, start=1):
                if not isinstance(week, dict):
                    raise TypeError(f"Week {w} must be dict")
        
                for day in DAY_ORDER:
                    shifts = week.get(day)
                    if not shifts:
                        raise ValueError(f"Missing day {day} in Week {w}")
        
                    for shift in ["ğŸŸ¨", "ğŸŸ§"]:
                        if shift not in shifts:
                            raise ValueError(f"Missing {shift} in Week {w}, {day}")
                        if isinstance(shifts[shift], list):
                            raise ValueError(
                                f"Overlap not allowed in Week {w}, {day}, {shift}"
                            )
        
                    if "ğŸŸ¦" not in shifts:
                        raise ValueError(f"Night shift missing in Week {w}, {day}")
        
            return state
        --- CODE END ---
    patterns/
      pattern_a_24x7.py
        --- CODE START ---
        # def build_pattern_a(state):
        #     """
        #     SECTION 1 â€” 24x7
        #     Week 1 base pattern (anchor week).
        #     Overlaps allowed ONLY in this week.
        #     """
        #
        #     week1 = {
        #         "Mon": {"ğŸŸ¨": "P2", "ğŸŸ§": "P3", "ğŸŸ¦": "P1"},
        #         "Tue": {"ğŸŸ¨": "P2", "ğŸŸ§": "P3", "ğŸŸ¦": "P1"},
        #         "Wed": {"ğŸŸ¨": "P2", "ğŸŸ§": "P3", "ğŸŸ¦": "P1"},
        #         "Thu": {"ğŸŸ¨": "P2", "ğŸŸ§": "P4", "ğŸŸ¦": "P1"},
        #         "Fri": {"ğŸŸ¨": "P2", "ğŸŸ§": "P4", "ğŸŸ¦": "P1"},
        #         "Sat": {"ğŸŸ¨": "P3", "ğŸŸ§": "P5", "ğŸŸ¦": "P1"},
        #         "Sun": {"ğŸŸ¨": "P3", "ğŸŸ§": "P5", "ğŸŸ¦": "P1"},
        #     }
        #
        #     state.final_schedule = [week1]
        #     return state
        
        
        
        # def build_pattern_a(state):
        #     """
        #     Section 1 â€“ 24x7 base pattern (Week 1)
        #     """
        #     week1 = {
        #         "Mon": {"ğŸŸ¨": "P2", "ğŸŸ§": "P3", "ğŸŸ¦": "P1"},
        #         "Tue": {"ğŸŸ¨": "P2", "ğŸŸ§": "P3", "ğŸŸ¦": "P1"},
        #         "Wed": {"ğŸŸ¨": "P2", "ğŸŸ§": "P3", "ğŸŸ¦": "P1"},
        #         "Thu": {"ğŸŸ¨": "P2", "ğŸŸ§": "P4", "ğŸŸ¦": "P1"},
        #         "Fri": {"ğŸŸ¨": "P2", "ğŸŸ§": "P4", "ğŸŸ¦": "P1"},
        #         "Sat": {"ğŸŸ¨": "P3", "ğŸŸ§": "P5", "ğŸŸ¦": "P1"},
        #         "Sun": {"ğŸŸ¨": "P3", "ğŸŸ§": "P5", "ğŸŸ¦": "P1"},
        #     }
        #
        #     state.final_schedule = [week1]
        #
        #     state.night_streak = {"P1": 7}
        #
        #     return state
        
        
        def build_pattern_a(state):
            """
            24Ã—7 BASE PATTERN (Week-1)
            HARD RULES:
            - Max 5 consecutive Nights
            - Single person per shift
            """
        
            week1 = {
                "Mon": {"ğŸŸ¨": "P2", "ğŸŸ§": "P3", "ğŸŸ¦": "P1"},
                "Tue": {"ğŸŸ¨": "P2", "ğŸŸ§": "P3", "ğŸŸ¦": "P1"},
                "Wed": {"ğŸŸ¨": "P2", "ğŸŸ§": "P3", "ğŸŸ¦": "P1"},
                "Thu": {"ğŸŸ¨": "P2", "ğŸŸ§": "P4", "ğŸŸ¦": "P1"},
                "Fri": {"ğŸŸ¨": "P2", "ğŸŸ§": "P4", "ğŸŸ¦": "P1"},
        
                # ğŸ” Night rotates after 5
                "Sat": {"ğŸŸ¨": "P3", "ğŸŸ§": "P5", "ğŸŸ¦": "P2"},
                "Sun": {"ğŸŸ¨": "P3", "ğŸŸ§": "P5", "ğŸŸ¦": "P2"},
            }
        
            state.final_schedule = [week1]
            return state
        --- CODE END ---
      pattern_b_24x5.py
        --- CODE START ---
        def build_pattern_b(state):
            week1 = {}
        
            for day in ["Mon", "Tue", "Wed", "Thu", "Fri"]:
                week1[day] = {
                    "ğŸŸ¨": "P2",
                    "ğŸŸ§": "P3",
                    "ğŸŸ¦": "P1"
                }
        
            state.final_schedule = [week1]
            return state
        --- CODE END ---
      pattern_c_16x5.py
        --- CODE START ---
        def build_pattern_c(state):
            week1 = {}
        
            for day in ["Mon", "Tue", "Wed", "Thu", "Fri"]:
                week1[day] = {
                    "ğŸŸ¨": "P1",
                    "ğŸŸ§": "P2"
                }
        
            state.final_schedule = [week1]
            return state
        --- CODE END ---
    schemas/
      intent.py
        --- CODE START ---
        from typing import Optional, List, Dict
        from pydantic import BaseModel
        
        class LeaveIntent(BaseModel):
            name: str
            date: str  # ISO format preferred
        
        class Intent(BaseModel):
            intent_type: str  # greeting | create_schedule | add_leave | update | unknown
            service_type: Optional[str] = None  # 24x7 | 24x5 | 16x5
            weeks: Optional[int] = None
            leaves: List[LeaveIntent] = []
            confidence: float
        --- CODE END ---
    utils/
      dates.py
        --- CODE START ---
        from datetime import datetime, timedelta
        import pytz
        
        IST = pytz.timezone("Asia/Kolkata")
        
        def get_monday_of_current_week():
            today = datetime.now(IST).date()
            return today - timedelta(days=today.weekday())
        
        def generate_week_dates(start_monday, weeks=1):
            dates = []
            for w in range(weeks):
                for d in range(7):
                    dates.append(start_monday + timedelta(days=w * 7 + d))
            return dates
        --- CODE END ---
      helpers.py
        --- CODE START ---
        --- CODE END ---
